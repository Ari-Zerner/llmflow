# Goal

We want to rapidly iterate on different approaches to using LLMs.

# Idea

Invent a domain-specific language for chaining together LLM calls. Then, we can use this to express different approaches, and store the output of an approach along with a simple representation of the approach, rather than the approach being coupled with other code.

# Initial DSL design proposal

## Program

A program is a JSON object with the following properties:
- `doc`: string (optional). A high-level description of the program.
- `routines`: dict of string->routine. The keys are the names of the routines, and a routine is a JSON object with a `type` property, an optional `doc` property, and other properties specific to the routine type. A routine takes inputs and/or returns outputs.
- `main`: string. The name of the routine to call when the program is run.

The output of running a program should be a JSON object with the following properties:
- `program`: object. The program that was run.
- `outputs`: object. The outputs of the main routine.
- `trace`: object. A trace of the program's execution. Implementation TBD, but will likely be a tree structure, where traces of control routines contain trace objects for the routines they call, traces of data routines are "leaf nodes", and the root is the main routine.

## Variables

Variables are the mechanism for passing data between nodes. They have names and types. Variables use a simple type system (`T` represents a base type):
- `string`
- `number`
- `boolean`
- `T[]`: a list of T
- `T?`: an optional T

## Routines

### Data routines

#### prompt

A `prompt` routine makes a single call to an LLM. It has the following properties:

- `dev_msg`: string. A static string to pass to the LLM as a message with the "developer" role.
- `user_msg`: string. A template string to pass to the LLM as a message with the "user" role. Templates incorporate input variables using a simple `${var_name}` syntax.
- `outputs`: non-empty dict of string->string. Each entry is the name and type of an output to be generated by the LLM.

#### define

A `define` routine can rename, drop, or duplicate variables, as well as create variables from literal values. It has the following properties:
- `outputs`: object. A dictionary of string->string|object. Each key is the name of an output, and each value is either the name of an input or an object with `type` and `value` properties.

#### code

A `code` routine runs arbitrary code. The routine's inputs will be available to the code as an object called `input` and the code must be an expression that evaluates to a JSON object where all values have types that exist in the DSL's type system, which becomes the routine's outputs. It has the following properties:
- `code`: string. The code to run.

### Control routines

#### if

An `if` routine takes a boolean or optional variable and passes its inputs (including the condition) to the `then` routine if the condition is true or non-null, or the `else` routine if the condition is false or null, and returns the outputs of the routine that was executed. It has the following properties:
- `condition`: string. The name of the input variable to branch on.
- `then`: string. The name of the routine to branch to if the condition is true/non-null.
- `else`: string. The name of the routine to branch to if the condition is false/null.

#### join

A `join` routine passes its inputs as inputs to multiple routines, and merges the outputs of the routines into a single output. It has the following properties:
- `routines`: array of strings. The names of the routines to merge. If output names collide, the last routine to contribute an output by that name will win.

#### compose

A `compose` routine composes multiple routines together, passing its inputs as inputs to the first routine, and passing the output of each routine as the input to the next, outputting the output of the last routine. It has the following properties:
- `routines`: array of strings. The names of the routines to compose.

## Syntax

In the first iteration of this system, we'll just use JSON files to represent programs. Later, it might be nice to create a specialized syntax for routines that can be expressed concisely. For instance:
- `file`: `output<-path`
- `if`: `condition ? then : else`
- `join`: `routine1 + routine2 + ...`
- `compose`: `routine1; routine2; ...`

