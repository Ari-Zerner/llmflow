# Goal

We want to rapidly iterate on different approaches to using LLMs.

# Idea

Invent a domain-specific language for chaining together LLM calls. Then, we can use this to express different approaches, and store the output of an approach along with a simple representation of the approach, rather than the approach being coupled with other code.

# Usage

## Setup

1. Install dependencies:
```bash
npm install
```

2. Create a `.env` file with your OpenAI API key:
```
OPENAI_API_KEY=your_key_here
```

## Running Programs

Run a program using:
```bash
npm start -- <program_file.json> --inputs 'key:value, key2:value2' [--output output.json]
```

For example:
```bash
npm start -- src/examples/test_program.json --inputs 'name:Alice, time_of_day:morning'
```

The output will be written to output.json (or the specified output file) and will contain:
- The program that was run
- The inputs provided
- The outputs generated
- A complete trace of the execution

# DSL Design

## Program

A program is a JSON object with the following properties:
- `doc`: string (optional). A high-level description of the program.
- `routines`: dict of string->routine. The keys are the names of the routines, and a routine is a JSON object with the following common properties:
  - `type`: string. The type of the routine.
  - `doc`: string (optional). A description of what the routine does.
  - `passthrough`: array of strings (optional). Names of input variables to pass through unchanged to the outputs.
  Other properties are specific to the routine type.
- `main`: string. The name of the routine to call when the program is run.

The output of running a program should be a JSON object with the following properties:
- `program`: object. The program that was run.
- `outputs`: object. The outputs of the main routine.
- `trace`: object. A trace of the program's execution. Implementation TBD, but will likely be a tree structure, where traces of control routines contain trace objects for the routines they call, traces of data routines are "leaf nodes", and the root is the main routine.

## Variables

Variables are the mechanism for passing data between nodes. They have names and types. Variables use a simple type system (`T` represents a base type):
- `string`
- `number`
- `boolean`
- `T[]`: a list of T
- `T?`: an optional T

### Variable Passing Rules
- Control routines (`if`, `compose`, `join`) automatically pass their inputs to their child routines
- The `if` routine passes inputs to the selected branch
- The `define` routine can rename variables or create new ones from literals
- The `prompt` routine generates new variables based on its outputs specification
- The `code` routine generates new variables from its code expression
- Use `passthrough` only when you need to explicitly preserve variables that would otherwise be dropped

## Routines

### Data routines

#### prompt

A `prompt` routine makes a single call to an LLM. It has the following properties:

- `dev_msg`: string. A static string to pass to the LLM as a message with the "developer" role.
- `user_msg`: string. A template string to pass to the LLM as a message with the "user" role. Templates incorporate input variables using a simple `${var_name}` syntax.
- `outputs`: non-empty dict of string->string. Each entry is the name and type of an output to be generated by the LLM. The LLM will return a structured object matching these outputs.

#### define

A `define` routine can rename, drop, or duplicate variables, as well as create variables from literal values. It has the following properties:
- `outputs`: object. A dictionary of string->string|object. Each key is the name of an output, and each value is either the name of an input or an object with `type` and `value` properties.

#### code

A `code` routine runs arbitrary code. The routine's inputs will be available to the code as an object called `input` and the code must be an expression that evaluates to a JSON object where all values have types that exist in the DSL's type system, which becomes the routine's outputs. It has the following properties:
- `code`: string. The code to run.

### Control routines

#### if

An `if` routine takes a boolean or optional variable and passes its inputs (including the condition) to the `then` routine if the condition is true or non-null, or the `else` routine if the condition is false or null, and returns the outputs of the routine that was executed. It has the following properties:
- `condition`: string. The name of the input variable to branch on.
- `then`: string. The name of the routine to branch to if the condition is true/non-null.
- `else`: string. The name of the routine to branch to if the condition is false/null.

#### join

A `join` routine passes its inputs as inputs to multiple routines, and merges the outputs of the routines into a single output. It has the following properties:
- `routines`: array of strings. The names of the routines to merge. If output names collide, the last routine to contribute an output by that name will win.

#### compose

A `compose` routine composes multiple routines together, passing its inputs as inputs to the first routine, and passing the output of each routine as the input to the next, outputting the output of the last routine. It has the following properties:
- `routines`: array of strings. The names of the routines to compose.

## Syntax

In the first iteration of this system, we'll just use JSON files to represent programs. Later, it might be nice to create a specialized syntax for routines that can be expressed concisely. For instance:
- `if`: `condition ? then : else`
- `join`: `routine1 + routine2 + ...`
- `compose`: `routine1; routine2; ...`
